#!/usr/bin/env node

/**
 * üß™ SCRIPT DE VALIDACI√ìN - Sistema de Logging V2.0
 * 
 * Valida que el sistema de logging funcione correctamente:
 * 1. Console: Solo emojis y mensajes limpios
 * 2. File: Formato JSON t√©cnico id√©ntico a Cloud
 * 3. Cloud: Formato JSON t√©cnico id√©ntico a File
 * 
 * OBJETIVO: Verificar que File Logs = Cloud Logs (formato t√©cnico id√©ntico)
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Colores para terminal
const colors = {
    GREEN: '\x1b[32m',
    RED: '\x1b[31m',
    YELLOW: '\x1b[33m',
    CYAN: '\x1b[36m',
    RESET: '\x1b[0m',
    BOLD: '\x1b[1m'
};

console.log(`${colors.BOLD}${colors.CYAN}üß™ VALIDACI√ìN DEL SISTEMA DE LOGGING V2.0${colors.RESET}`);
console.log(`${colors.CYAN}Objetivo: Verificar que File Logs = Cloud Logs (formato t√©cnico id√©ntico)${colors.RESET}\n`);

/**
 * üß™ CASOS DE PRUEBA
 */
const testCases = [
    {
        name: 'Mensaje de Usuario',
        level: 'INFO',
        category: 'MESSAGE_RECEIVED',
        message: 'Mensaje recibido del usuario',
        details: {
            userId: '573001234567',
            messageType: 'text',
            body: 'Hola, necesito ayuda con mi reserva'
        }
    },
    {
        name: 'Funci√≥n Ejecut√°ndose',
        level: 'INFO',
        category: 'FUNCTION_EXECUTING',
        message: 'Ejecutando funci√≥n check_availability',
        details: {
            userId: '573001234567',
            functionName: 'check_availability',
            args: {
                startDate: '2025-01-15',
                endDate: '2025-01-20'
            }
        }
    },
    {
        name: 'Respuesta Beds24',
        level: 'SUCCESS',
        category: 'BEDS24_RESPONSE_DETAIL',
        message: 'Respuesta recibida de Beds24',
        details: {
            status: 200,
            dataCount: 3,
            properties: ['Apartamento Centro', 'Casa Playa', 'Loft Moderno']
        }
    },
    {
        name: 'Error del Sistema',
        level: 'ERROR',
        category: 'OPENAI_REQUEST',
        message: 'Error en solicitud a OpenAI',
        details: {
            error: 'Timeout despu√©s de 30 segundos',
            threadId: 'thread_abc123def456',
            userId: '573001234567'
        }
    },
    {
        name: 'Inicio del Servidor',
        level: 'SUCCESS',
        category: 'SERVER_START',
        message: 'Servidor HTTP iniciado',
        details: {
            host: 'localhost',
            port: 3008,
            environment: 'development'
        }
    }
];

/**
 * üéØ FUNCI√ìN PRINCIPAL DE VALIDACI√ìN
 */
async function validateLoggingSystem() {
    console.log(`${colors.YELLOW}üìã Ejecutando ${testCases.length} casos de prueba...${colors.RESET}\n`);
    
    let passedTests = 0;
    let failedTests = 0;
    
    for (const [index, testCase] of testCases.entries()) {
        console.log(`${colors.CYAN}${index + 1}. Validando: ${testCase.name}${colors.RESET}`);
        
        try {
            const result = await validateTestCase(testCase);
            
            if (result.success) {
                console.log(`${colors.GREEN}   ‚úÖ PASSED${colors.RESET}`);
                passedTests++;
            } else {
                console.log(`${colors.RED}   ‚ùå FAILED: ${result.error}${colors.RESET}`);
                failedTests++;
            }
            
            // Mostrar detalles del resultado
            if (result.details) {
                console.log(`${colors.YELLOW}   üìä Detalles:${colors.RESET}`);
                console.log(`      Console: ${result.details.console ? '‚úÖ' : '‚ùå'}`);
                console.log(`      File: ${result.details.file ? '‚úÖ' : '‚ùå'}`);
                console.log(`      Cloud: ${result.details.cloud ? '‚úÖ' : '‚ùå'}`);
                
                if (result.details.formatMatch !== undefined) {
                    console.log(`      File = Cloud: ${result.details.formatMatch ? '‚úÖ' : '‚ùå'}`);
                }
            }
            
        } catch (error) {
            console.log(`${colors.RED}   ‚ùå ERROR: ${error.message}${colors.RESET}`);
            failedTests++;
        }
        
        console.log('');
    }
    
    // Resumen final
    console.log(`${colors.BOLD}${colors.CYAN}üìä RESUMEN DE VALIDACI√ìN${colors.RESET}`);
    console.log(`${colors.GREEN}‚úÖ Pruebas exitosas: ${passedTests}${colors.RESET}`);
    console.log(`${colors.RED}‚ùå Pruebas fallidas: ${failedTests}${colors.RESET}`);
    console.log(`${colors.CYAN}üìà Porcentaje de √©xito: ${Math.round((passedTests / testCases.length) * 100)}%${colors.RESET}\n`);
    
    if (failedTests === 0) {
        console.log(`${colors.GREEN}${colors.BOLD}üéâ ¬°VALIDACI√ìN EXITOSA! Sistema de logging V2.0 funcionando correctamente${colors.RESET}`);
        console.log(`${colors.GREEN}   ‚Ä¢ Console: Logs limpios con emojis ‚úÖ${colors.RESET}`);
        console.log(`${colors.GREEN}   ‚Ä¢ File: Formato JSON t√©cnico ‚úÖ${colors.RESET}`);
        console.log(`${colors.GREEN}   ‚Ä¢ Cloud: Formato JSON t√©cnico ‚úÖ${colors.RESET}`);
        console.log(`${colors.GREEN}   ‚Ä¢ File = Cloud: Formato id√©ntico ‚úÖ${colors.RESET}`);
        return true;
    } else {
        console.log(`${colors.RED}${colors.BOLD}üö® VALIDACI√ìN FALLIDA! Revisar implementaci√≥n${colors.RESET}`);
        return false;
    }
}

/**
 * üß™ VALIDAR CASO DE PRUEBA INDIVIDUAL
 */
async function validateTestCase(testCase) {
    const result = {
        success: false,
        error: null,
        details: {
            console: false,
            file: false,
            cloud: false,
            formatMatch: false
        }
    };
    
    try {
        // Crear logs de prueba
        const testLogs = await createTestLogs(testCase);
        
        // Validar que se crearon correctamente
        result.details.console = testLogs.console !== null;
        result.details.file = testLogs.file !== null;
        result.details.cloud = testLogs.cloud !== null;
        
        // Validar formato File = Cloud
        if (testLogs.file && testLogs.cloud) {
            result.details.formatMatch = validateFormatMatch(testLogs.file, testLogs.cloud);
        }
        
        // Validar contenido espec√≠fico
        const contentValidation = validateLogContent(testCase, testLogs);
        
        result.success = result.details.console && result.details.file && 
                        result.details.cloud && result.details.formatMatch && 
                        contentValidation.success;
        
        if (!result.success) {
            result.error = contentValidation.error || 'Formato o contenido inv√°lido';
        }
        
    } catch (error) {
        result.error = error.message;
    }
    
    return result;
}

/**
 * üèóÔ∏è CREAR LOGS DE PRUEBA
 */
async function createTestLogs(testCase) {
    // Simular el sistema de logging
    const mockLogs = {
        console: null,
        file: null,
        cloud: null
    };
    
    try {
        // Importar el sistema de logging
        const loggingPath = path.join(__dirname, '..', 'src', 'utils', 'logging');
        
        // Simular environment para cada tipo
        const originalKService = process.env.K_SERVICE;
        
        // 1. Test Console Logger (desarrollo local)
        delete process.env.K_SERVICE;
        const { formatConsoleLogEntry, shouldShowInConsole } = require(path.join(loggingPath, 'formatters'));
        
        if (shouldShowInConsole(testCase.category)) {
            mockLogs.console = formatConsoleLogEntry(testCase.level, testCase.category, testCase.message, testCase.details);
        } else {
            mockLogs.console = ''; // No se muestra en console
        }
        
        // 2. Test File Logger (desarrollo local)
        const { formatTechnicalLogEntry } = require(path.join(loggingPath, 'formatters'));
        const mockLogEntry = {
            timestamp: new Date().toISOString(),
            level: testCase.level,
            category: testCase.category,
            message: testCase.message,
            details: testCase.details,
            environment: 'development'
        };
        
        mockLogs.file = formatTechnicalLogEntry(mockLogEntry);
        
        // 3. Test Cloud Logger (producci√≥n)
        process.env.K_SERVICE = 'test-service';
        mockLogs.cloud = formatTechnicalLogEntry({
            ...mockLogEntry,
            environment: 'production'
        });
        
        // Restaurar environment
        if (originalKService) {
            process.env.K_SERVICE = originalKService;
        } else {
            delete process.env.K_SERVICE;
        }
        
    } catch (error) {
        throw new Error(`Error creando logs de prueba: ${error.message}`);
    }
    
    return mockLogs;
}

/**
 * üîç VALIDAR COINCIDENCIA DE FORMATO
 */
function validateFormatMatch(fileLog, cloudLog) {
    try {
        // Parsear ambos logs JSON
        const fileData = JSON.parse(fileLog);
        const cloudData = JSON.parse(cloudLog);
        
        // Comparar estructura b√°sica
        const fileKeys = Object.keys(fileData).sort();
        const cloudKeys = Object.keys(cloudData).sort();
        
        if (JSON.stringify(fileKeys) !== JSON.stringify(cloudKeys)) {
            return false;
        }
        
        // Comparar campos cr√≠ticos
        const criticalFields = ['severity', 'jsonPayload', 'labels', 'resource'];
        
        for (const field of criticalFields) {
            if (fileData[field] && cloudData[field]) {
                // Comparar estructura del campo
                const fileFieldKeys = Object.keys(fileData[field]).sort();
                const cloudFieldKeys = Object.keys(cloudData[field]).sort();
                
                if (JSON.stringify(fileFieldKeys) !== JSON.stringify(cloudFieldKeys)) {
                    return false;
                }
            }
        }
        
        return true;
        
    } catch (error) {
        return false;
    }
}

/**
 * üìù VALIDAR CONTENIDO DE LOGS
 */
function validateLogContent(testCase, testLogs) {
    const result = { success: true, error: null };
    
    try {
        // Validar Console Log
        if (testLogs.console) {
            // Debe contener emoji
            const hasEmoji = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/u.test(testLogs.console);
            if (!hasEmoji) {
                result.success = false;
                result.error = 'Console log debe contener emoji';
                return result;
            }
            
            // No debe contener JSON
            if (testLogs.console.includes('{') || testLogs.console.includes('}')) {
                result.success = false;
                result.error = 'Console log no debe contener JSON';
                return result;
            }
        }
        
        // Validar File Log
        if (testLogs.file) {
            try {
                const fileData = JSON.parse(testLogs.file);
                
                // Debe tener estructura JSON v√°lida
                if (!fileData.jsonPayload || !fileData.severity) {
                    result.success = false;
                    result.error = 'File log debe tener estructura JSON v√°lida';
                    return result;
                }
                
                // Debe contener la categor√≠a
                if (!fileData.jsonPayload.category || fileData.jsonPayload.category !== testCase.category) {
                    result.success = false;
                    result.error = 'File log debe contener categor√≠a correcta';
                    return result;
                }
                
            } catch (error) {
                result.success = false;
                result.error = 'File log debe ser JSON v√°lido';
                return result;
            }
        }
        
        // Validar Cloud Log
        if (testLogs.cloud) {
            try {
                const cloudData = JSON.parse(testLogs.cloud);
                
                // Debe tener estructura JSON v√°lida
                if (!cloudData.jsonPayload || !cloudData.severity) {
                    result.success = false;
                    result.error = 'Cloud log debe tener estructura JSON v√°lida';
                    return result;
                }
                
                // Debe contener la categor√≠a
                if (!cloudData.jsonPayload.category || cloudData.jsonPayload.category !== testCase.category) {
                    result.success = false;
                    result.error = 'Cloud log debe contener categor√≠a correcta';
                    return result;
                }
                
            } catch (error) {
                result.success = false;
                result.error = 'Cloud log debe ser JSON v√°lido';
                return result;
            }
        }
        
    } catch (error) {
        result.success = false;
        result.error = `Error validando contenido: ${error.message}`;
    }
    
    return result;
}

/**
 * üöÄ EJECUTAR VALIDACI√ìN
 */
if (require.main === module) {
    validateLoggingSystem()
        .then(success => {
            process.exit(success ? 0 : 1);
        })
        .catch(error => {
            console.error(`${colors.RED}${colors.BOLD}üí• Error cr√≠tico: ${error.message}${colors.RESET}`);
            process.exit(1);
        });
}

module.exports = { validateLoggingSystem, validateTestCase }; 