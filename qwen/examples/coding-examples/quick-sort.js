/**
 * Quick Sort Algorithm - Generated by Qwen3-Coder
 * 
 * Este es un ejemplo de c칩digo generado por Qwen3-Coder que demuestra
 * la implementaci칩n del algoritmo Quick Sort con optimizaciones.
 */

/**
 * Intercambia dos elementos en un array
 * @param {Array} arr - Array donde intercambiar elementos
 * @param {number} i - 칈ndice del primer elemento
 * @param {number} j - 칈ndice del segundo elemento
 */
function swap(arr, i, j) {
    [arr[i], arr[j]] = [arr[j], arr[i]];
}

/**
 * Particiona el array usando el 칰ltimo elemento como pivote
 * @param {Array} arr - Array a particionar
 * @param {number} low - 칈ndice inicial
 * @param {number} high - 칈ndice final
 * @returns {number} - 칈ndice del pivote en su posici칩n final
 */
function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    
    swap(arr, i + 1, high);
    return i + 1;
}

/**
 * Implementaci칩n recursiva de Quick Sort
 * @param {Array} arr - Array a ordenar
 * @param {number} low - 칈ndice inicial (opcional)
 * @param {number} high - 칈ndice final (opcional)
 */
function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

/**
 * Versi칩n optimizada de Quick Sort con selecci칩n de pivote inteligente
 * @param {Array} arr - Array a ordenar
 * @param {number} low - 칈ndice inicial
 * @param {number} high - 칈ndice final
 */
function quickSortOptimized(arr, low = 0, high = arr.length - 1) {
    if (high - low <= 10) {
        // Para arrays peque침os, usar insertion sort
        insertionSort(arr, low, high);
        return;
    }
    
    if (low < high) {
        const pi = partitionOptimized(arr, low, high);
        quickSortOptimized(arr, low, pi - 1);
        quickSortOptimized(arr, pi + 1, high);
    }
}

/**
 * Partici칩n optimizada con selecci칩n de pivote mediana de tres
 * @param {Array} arr - Array a particionar
 * @param {number} low - 칈ndice inicial
 * @param {number} high - 칈ndice final
 * @returns {number} - 칈ndice del pivote
 */
function partitionOptimized(arr, low, high) {
    // Seleccionar pivote usando mediana de tres
    const mid = Math.floor((low + high) / 2);
    const pivot = medianOfThree(arr, low, mid, high);
    swap(arr, pivot, high);
    
    return partition(arr, low, high);
}

/**
 * Encuentra la mediana de tres elementos
 * @param {Array} arr - Array
 * @param {number} a - Primer 칤ndice
 * @param {number} b - Segundo 칤ndice
 * @param {number} c - Tercer 칤ndice
 * @returns {number} - 칈ndice de la mediana
 */
function medianOfThree(arr, a, b, c) {
    const valA = arr[a];
    const valB = arr[b];
    const valC = arr[c];
    
    if (valA <= valB && valB <= valC) return b;
    if (valA <= valC && valC <= valB) return c;
    if (valB <= valA && valA <= valC) return a;
    if (valB <= valC && valC <= valA) return c;
    if (valC <= valA && valA <= valB) return a;
    return b;
}

/**
 * Insertion Sort para arrays peque침os
 * @param {Array} arr - Array a ordenar
 * @param {number} low - 칈ndice inicial
 * @param {number} high - 칈ndice final
 */
function insertionSort(arr, low, high) {
    for (let i = low + 1; i <= high; i++) {
        const key = arr[i];
        let j = i - 1;
        
        while (j >= low && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}

/**
 * Funci칩n de utilidad para verificar si un array est치 ordenado
 * @param {Array} arr - Array a verificar
 * @returns {boolean} - true si est치 ordenado, false en caso contrario
 */
function isSorted(arr) {
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < arr[i - 1]) {
            return false;
        }
    }
    return true;
}

/**
 * Funci칩n de utilidad para generar arrays de prueba
 * @param {number} size - Tama침o del array
 * @param {number} max - Valor m치ximo (opcional)
 * @returns {Array} - Array de n칰meros aleatorios
 */
function generateTestArray(size, max = 1000) {
    return Array.from({ length: size }, () => Math.floor(Math.random() * max));
}

// Ejemplo de uso
function demonstrateQuickSort() {
    console.log("游 Demostraci칩n de Quick Sort generado por Qwen3-Coder");
    console.log("=" .repeat(50));
    
    // Array de prueba
    const testArray = generateTestArray(20, 100);
    console.log("Array original:", testArray);
    
    // Clonar para comparar
    const arrayCopy = [...testArray];
    
    // Quick Sort b치sico
    quickSort(arrayCopy);
    console.log("Array ordenado (b치sico):", arrayCopy);
    console.log("쮼st치 ordenado?", isSorted(arrayCopy));
    
    // Quick Sort optimizado
    const optimizedArray = [...testArray];
    quickSortOptimized(optimizedArray);
    console.log("Array ordenado (optimizado):", optimizedArray);
    console.log("쮼st치 ordenado?", isSorted(optimizedArray));
    
    // Comparar resultados
    const arraysEqual = JSON.stringify(arrayCopy) === JSON.stringify(optimizedArray);
    console.log("쯃os resultados son iguales?", arraysEqual);
}

// Ejecutar demostraci칩n si este archivo se ejecuta directamente
if (require.main === module) {
    demonstrateQuickSort();
}

module.exports = {
    quickSort,
    quickSortOptimized,
    partition,
    partitionOptimized,
    swap,
    isSorted,
    generateTestArray
}; 